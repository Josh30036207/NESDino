;
; File generated by cc65 v 2.19 - Git bb1b5c3
;
	.fopt		compiler,"cc65 v 2.19 - Git bb1b5c3"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	on
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.dbg		file, "game.c", 6901, 1715356774
	.dbg		file, "LIB/neslib.h", 9196, 1701627949
	.dbg		file, "LIB/nesdoug.h", 6756, 1701627949
	.dbg		file, "game.h", 2245, 1715356306
	.dbg		file, "BG/maps.c", 548, 1714855890
	.dbg		file, "sprites.h", 2158, 1715356275
	.forceimport	__STARTUP__
	.dbg		sym, "pal_bg", "00", extern, "_pal_bg"
	.dbg		sym, "pal_spr", "00", extern, "_pal_spr"
	.dbg		sym, "ppu_wait_nmi", "00", extern, "_ppu_wait_nmi"
	.dbg		sym, "ppu_off", "00", extern, "_ppu_off"
	.dbg		sym, "ppu_on_all", "00", extern, "_ppu_on_all"
	.dbg		sym, "oam_clear", "00", extern, "_oam_clear"
	.dbg		sym, "oam_meta_spr", "00", extern, "_oam_meta_spr"
	.dbg		sym, "pad_poll", "00", extern, "_pad_poll"
	.dbg		sym, "bank_spr", "00", extern, "_bank_spr"
	.dbg		sym, "rand8", "00", extern, "_rand8"
	.dbg		sym, "vram_adr", "00", extern, "_vram_adr"
	.dbg		sym, "memcpy", "00", extern, "_memcpy"
	.dbg		sym, "set_vram_buffer", "00", extern, "_set_vram_buffer"
	.dbg		sym, "get_pad_new", "00", extern, "_get_pad_new"
	.dbg		sym, "check_collision", "00", extern, "_check_collision"
	.dbg		sym, "get_ppu_addr", "00", extern, "_get_ppu_addr"
	.dbg		sym, "set_data_pointer", "00", extern, "_set_data_pointer"
	.dbg		sym, "set_mt_pointer", "00", extern, "_set_mt_pointer"
	.dbg		sym, "buffer_1_mt", "00", extern, "_buffer_1_mt"
	.dbg		sym, "buffer_4_mt", "00", extern, "_buffer_4_mt"
	.dbg		sym, "flush_vram_update2", "00", extern, "_flush_vram_update2"
	.import		_pal_bg
	.import		_pal_spr
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_meta_spr
	.import		_pad_poll
	.import		_bank_spr
	.import		_rand8
	.import		_vram_adr
	.import		_memcpy
	.import		_set_vram_buffer
	.import		_get_pad_new
	.import		_check_collision
	.import		_get_ppu_addr
	.import		_set_data_pointer
	.import		_set_mt_pointer
	.import		_buffer_1_mt
	.import		_buffer_4_mt
	.import		_flush_vram_update2
	.export		_map0
	.export		_dinoStill
	.export		_dinoSp1
	.export		_dinoSp2
	.export		_cSp1
	.export		_cSp2
	.export		_bSp
	.export		_clSp
	.export		_clSp2
	.export		_clSp3
	.export		_clSp4
	.export		_null
	.export		_paletteBg
	.export		_paletteSp
	.export		_mapTiles
	.export		_pad1
	.export		_pad1_new
	.export		_collision
	.export		_which_bg
	.export		_p_maps
	.export		_coordinates
	.export		_steptimer
	.export		_maxSTimer
	.export		_stepAlt
	.export		_dinoSprite
	.export		_obSprite
	.export		_obSprite2
	.export		_birbSprite
	.export		_cloudSprite
	.export		_score
	.export		_hiScr
	.export		_test
	.export		_loop
	.export		_i
	.export		_trwTmr
	.export		_rng
	.export		_jump
	.export		_fall
	.export		_grnd
	.export		_lose
	.export		_filpFlop
	.export		_dino
	.export		_cacti
	.export		_cacti2
	.export		_birb
	.export		_cloud
	.export		_obs
	.export		_c_map
	.export		_test_map
	.export		_All_Collision_Maps
	.export		_drawSprites
	.export		_moveCloud
	.export		_walk
	.export		_checkCollision
	.export		_draw_bg
	.export		_abBtn
	.export		_ssBtn
	.export		_moveObs
	.export		_gameOver
	.export		_displayScore
	.export		_reset
	.export		_rtnDig
	.export		_digit
	.export		_counter
	.export		_scrBrd
	.export		_hiBrd
	.export		_address
	.export		_x
	.export		_y
	.export		_index
	.export		_posChk
	.export		_pause
	.export		_main

.segment	"DATA"

_mapTiles:
	.byte	$05
	.byte	$05
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$03
	.byte	$03
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$04
	.byte	$04
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$60
	.byte	$61
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$62
	.byte	$63
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$64
	.byte	$65
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$66
	.byte	$67
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$68
	.byte	$69
	.byte	$78
	.byte	$79
	.byte	$00
	.byte	$05
	.byte	$30
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$31
	.byte	$32
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$40
	.byte	$40
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$40
	.byte	$40
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$40
	.byte	$05
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$40
	.byte	$40
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$40
	.byte	$40
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$40
	.byte	$05
	.byte	$05
	.byte	$05
	.byte	$00
_steptimer:
	.word	$0000
_maxSTimer:
	.word	$0004
_stepAlt:
	.byte	$30
_score:
	.word	$0000
_hiScr:
	.word	$0000
_loop:
	.word	$0001
_trwTmr:
	.word	$000A
_rng:
	.word	$0000
_jump:
	.byte	$30
_fall:
	.byte	$30
_grnd:
	.byte	$31
_lose:
	.byte	$30
_filpFlop:
	.byte	$30
_dino:
	.byte	$20
	.byte	$D3
	.byte	$0E
	.byte	$0E
	.byte	$30
	.addr	_dinoSp1
	.addr	_dinoSp1
_cacti:
	.byte	$FE
	.byte	$D3
	.byte	$06
	.byte	$0E
	.byte	$30
	.addr	_null
	.addr	_cSp1
_cacti2:
	.byte	$FE
	.byte	$D3
	.byte	$06
	.byte	$0A
	.byte	$30
	.addr	_null
	.addr	_cSp2
_birb:
	.byte	$FE
	.byte	$CA
	.byte	$0D
	.byte	$09
	.byte	$30
	.addr	_null
	.addr	_bSp
_cloud:
	.byte	$00
	.byte	$20
	.byte	$1E
	.byte	$0D
	.byte	$00
	.addr	_clSp
	.addr	_clSp
_counter:
	.word	$0000
_test:
	.word	$0000
_posChk:
	.word	$0000
_pause:
	.word	$0000

.segment	"RODATA"

_map0:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$03
	.byte	$04
	.byte	$05
	.byte	$02
	.byte	$02
	.byte	$03
	.byte	$01
	.byte	$03
	.byte	$04
	.byte	$02
	.byte	$03
	.byte	$05
	.byte	$01
	.byte	$02
_dinoStill:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$10
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$11
	.byte	$00
	.byte	$80
_dinoSp1:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$02
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$03
	.byte	$00
	.byte	$80
_dinoSp2:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$12
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$13
	.byte	$00
	.byte	$80
_cSp1:
	.byte	$00
	.byte	$00
	.byte	$04
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$14
	.byte	$00
	.byte	$80
_cSp2:
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$06
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$15
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$16
	.byte	$00
	.byte	$80
_bSp:
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$09
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$18
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$19
	.byte	$00
	.byte	$80
_clSp:
	.byte	$08
	.byte	$00
	.byte	$0B
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$0C
	.byte	$00
	.byte	$18
	.byte	$00
	.byte	$0D
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$1A
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$1B
	.byte	$00
	.byte	$10
	.byte	$08
	.byte	$1C
	.byte	$00
	.byte	$18
	.byte	$08
	.byte	$1D
	.byte	$00
	.byte	$80
_clSp2:
	.byte	$08
	.byte	$00
	.byte	$0B
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$0C
	.byte	$00
	.byte	$18
	.byte	$00
	.byte	$0D
	.byte	$00
	.byte	$08
	.byte	$08
	.byte	$1B
	.byte	$00
	.byte	$10
	.byte	$08
	.byte	$1C
	.byte	$00
	.byte	$18
	.byte	$08
	.byte	$1D
	.byte	$00
	.byte	$80
_clSp3:
	.byte	$10
	.byte	$00
	.byte	$0C
	.byte	$00
	.byte	$18
	.byte	$00
	.byte	$0D
	.byte	$00
	.byte	$10
	.byte	$08
	.byte	$1C
	.byte	$00
	.byte	$18
	.byte	$08
	.byte	$1D
	.byte	$00
	.byte	$80
_clSp4:
	.byte	$18
	.byte	$00
	.byte	$0D
	.byte	$00
	.byte	$18
	.byte	$08
	.byte	$1D
	.byte	$00
	.byte	$80
_null:
	.byte	$80
_paletteBg:
	.byte	$30
	.byte	$06
	.byte	$10
	.byte	$0F
	.byte	$0F
	.byte	$10
	.byte	$06
	.byte	$27
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_paletteSp:
	.byte	$30
	.byte	$06
	.byte	$10
	.byte	$0F
	.byte	$0F
	.byte	$10
	.byte	$06
	.byte	$27
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_All_Collision_Maps:
	.addr	_map0

.segment	"BSS"

_pad1:
	.res	1,$00
_pad1_new:
	.res	1,$00
_collision:
	.res	1,$00
_which_bg:
	.res	1,$00
_p_maps:
	.res	2,$00
_coordinates:
	.res	1,$00
_dinoSprite:
	.res	2,$00
_obSprite:
	.res	2,$00
_obSprite2:
	.res	2,$00
_birbSprite:
	.res	2,$00
_cloudSprite:
	.res	2,$00
_i:
	.res	2,$00
_obs:
	.res	27,$00
_c_map:
	.res	240,$00
_test_map:
	.res	240,$00
_digit:
	.res	2,$00
_scrBrd:
	.res	5,$00
_hiBrd:
	.res	5,$00
_address:
	.res	2,$00
_x:
	.res	1,$00
_y:
	.res	1,$00
_index:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ drawSprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_drawSprites: near

	.dbg	func, "drawSprites", "00", extern, "_drawSprites"

.segment	"CODE"

;
; ppu_wait_nmi(); // wait till beginning of the frame
;
	.dbg	line, "game.c", 66
	jsr     _ppu_wait_nmi
;
; oam_clear();
;
	.dbg	line, "game.c", 68
	jsr     _oam_clear
;
; bank_spr(1);//switch to player spritesheet
;
	.dbg	line, "game.c", 69
	lda     #$01
	jsr     _bank_spr
;
; {oam_meta_spr(dino.x, dino.y, dino.sprite);}//dino
;
	.dbg	line, "game.c", 72
	jsr     decsp2
	lda     _dino
	ldy     #$01
	sta     (sp),y
	lda     _dino+1
	dey
	sta     (sp),y
	lda     _dino+5
	ldx     _dino+5+1
	jsr     _oam_meta_spr
;
; {oam_meta_spr(cloud.x, cloud.y, cloud.sprite);}//cloud
;
	.dbg	line, "game.c", 73
	jsr     decsp2
	lda     _cloud
	ldy     #$01
	sta     (sp),y
	lda     _cloud+1
	dey
	sta     (sp),y
	lda     _cloud+5
	ldx     _cloud+5+1
	jsr     _oam_meta_spr
;
; for(i = 0; i < sizeof(obs) / (sizeof(char)*5); i++){oam_meta_spr(obs[i].x, obs[i].y, obs[i].sprite);}
;
	.dbg	line, "game.c", 74
	lda     #$00
	sta     _i
	sta     _i+1
L0002:	lda     _i+1
	cmp     #$00
	bne     L0006
	lda     _i
	cmp     #$05
L0006:	bcs     L0003
	jsr     decsp2
	lda     _i
	ldx     _i+1
	jsr     mulax9
	sta     ptr1
	txa
	clc
	adc     #>(_obs)
	sta     ptr1+1
	ldy     #<(_obs)
	lda     (ptr1),y
	ldy     #$01
	sta     (sp),y
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	lda     (ptr1),y
	dey
	sta     (sp),y
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	ldy     #$06
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     _oam_meta_spr
	inc     _i
	bne     L0002
	inc     _i+1
	jmp     L0002
;
; }
;
	.dbg	line, "game.c", 77
L0003:	rts

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ moveCloud (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_moveCloud: near

	.dbg	func, "moveCloud", "00", extern, "_moveCloud"

.segment	"CODE"

;
; cloud.x-=1;
;
	.dbg	line, "game.c", 220
	dec     _cloud
;
; if((cloud.x==0)&&(filpFlop == '0')){
;
	.dbg	line, "game.c", 221
	bne     L001D
	lda     _filpFlop
	cmp     #$30
	bne     L001D
;
; cloud.sprite = clSp2;
;
	.dbg	line, "game.c", 223
	lda     #>(_clSp2)
	sta     _cloud+5+1
	lda     #<(_clSp2)
	sta     _cloud+5
;
; else if((cloud.x==255)&&(filpFlop == '0')){cloud.sprite = clSp3;}
;
	.dbg	line, "game.c", 225
	rts
L001D:	lda     _cloud
	cmp     #$FF
	bne     L0020
	lda     _filpFlop
	cmp     #$30
	bne     L0020
	lda     #>(_clSp3)
	sta     _cloud+5+1
	lda     #<(_clSp3)
	sta     _cloud+5
;
; else if((cloud.x==239)&&(filpFlop == '0')){cloud.sprite = clSp4;}
;
	.dbg	line, "game.c", 226
	rts
L0020:	lda     _cloud
	cmp     #$EF
	bne     L0023
	lda     _filpFlop
	cmp     #$30
	bne     L0023
	lda     #>(_clSp4)
	sta     _cloud+5+1
	lda     #<(_clSp4)
	sta     _cloud+5
;
; else if(cloud.x==231){cloud.sprite = null;
;
	.dbg	line, "game.c", 227
	rts
L0023:	lda     _cloud
	cmp     #$E7
	bne     L0015
	lda     #>(_null)
	sta     _cloud+5+1
	lda     #<(_null)
	sta     _cloud+5
;
; if(filpFlop == '0'){cloud.sprite = null; filpFlop = '1';}
;
	.dbg	line, "game.c", 229
	lda     _filpFlop
	cmp     #$30
	bne     L0012
	lda     #>(_null)
	sta     _cloud+5+1
	lda     #<(_null)
	sta     _cloud+5
	lda     #$31
;
; else{cloud.sprite = clSp; filpFlop = '0';}
;
	.dbg	line, "game.c", 230
	jmp     L001A
L0012:	lda     #>(_clSp)
	sta     _cloud+5+1
	lda     #<(_clSp)
	sta     _cloud+5
	lda     #$30
L001A:	sta     _filpFlop
;
; cloud.y = 4*rand8();
;
	.dbg	line, "game.c", 233
L0013:	jsr     _rand8
	asl     a
	asl     a
	sta     _cloud+1
;
; }while(!((cloud.y <= 176) && (cloud.y >= 32)));
;
	.dbg	line, "game.c", 234
	cmp     #$B1
	bcs     L0024
	lda     _cloud+1
	cmp     #$20
	bcs     L0025
L0024:	lda     #$00
	jmp     L0019
L0025:	lda     #$01
L0019:	jsr     bnega
	bne     L0013
;
; }
;
	.dbg	line, "game.c", 237
L0015:	rts

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ walk (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_walk: near

	.dbg	func, "walk", "00", extern, "_walk"

.segment	"CODE"

;
; if(jump!='1'){
;
	.dbg	line, "game.c", 139
	lda     _jump
	cmp     #$31
	beq     L0008
;
; stepAlt = '0';
;
	.dbg	line, "game.c", 140
	lda     #$30
	sta     _stepAlt
;
; if(steptimer < maxSTimer){
;
	.dbg	line, "game.c", 141
	lda     _steptimer
	cmp     _maxSTimer
	lda     _steptimer+1
	sbc     _maxSTimer+1
	bvc     L000B
	eor     #$80
L000B:	bpl     L0003
;
; stepAlt = '1';
;
	.dbg	line, "game.c", 142
	lda     #$31
	sta     _stepAlt
;
; else if(steptimer > (maxSTimer*2)){
;
	.dbg	line, "game.c", 145
	jmp     L0005
L0003:	lda     _steptimer
	ldx     _steptimer+1
	jsr     pushax
	lda     _maxSTimer
	ldx     _maxSTimer+1
	stx     tmp1
	asl     a
	rol     tmp1
	ldx     tmp1
	jsr     tosicmp
	bmi     L0005
	beq     L0005
;
; steptimer = 0;
;
	.dbg	line, "game.c", 146
	lda     #$00
	sta     _steptimer
	sta     _steptimer+1
;
; steptimer++;
;
	.dbg	line, "game.c", 148
L0005:	inc     _steptimer
	bne     L0006
	inc     _steptimer+1
;
; switch(stepAlt){
;
	.dbg	line, "game.c", 150
L0006:	lda     _stepAlt
;
; }
;
	.dbg	line, "game.c", 157
	cmp     #$30
	beq     L0009
	cmp     #$31
	beq     L000A
	rts
;
; dino.sprite = dinoSp1;
;
	.dbg	line, "game.c", 152
L0009:	lda     #>(_dinoSp1)
	sta     _dino+5+1
	lda     #<(_dinoSp1)
;
; break;
;
	.dbg	line, "game.c", 153
	jmp     L000C
;
; dino.sprite = dinoSp2;
;
	.dbg	line, "game.c", 155
L000A:	lda     #>(_dinoSp2)
	sta     _dino+5+1
	lda     #<(_dinoSp2)
L000C:	sta     _dino+5
;
; }
;
	.dbg	line, "game.c", 162
L0008:	rts

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ checkCollision (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkCollision: near

	.dbg	func, "checkCollision", "00", extern, "_checkCollision"

.segment	"CODE"

;
; for(i = 0; i < sizeof(obs) / (sizeof(char)*5); i++){
;
	.dbg	line, "game.c", 241
	lda     #$00
	sta     _i
	sta     _i+1
L0002:	lda     _i+1
	cmp     #$00
	bne     L0006
	lda     _i
	cmp     #$05
L0006:	bcs     L0003
;
; collision = check_collision(&dino, &obs[i]); 
;
	.dbg	line, "game.c", 242
	lda     #<(_dino)
	ldx     #>(_dino)
	jsr     pushax
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	tay
	txa
	adc     #>(_obs)
	tax
	tya
	jsr     _check_collision
	sta     _collision
;
; if (collision){gameOver();}
;
	.dbg	line, "game.c", 243
	lda     _collision
	beq     L0004
	jsr     _gameOver
;
; for(i = 0; i < sizeof(obs) / (sizeof(char)*5); i++){
;
	.dbg	line, "game.c", 241
L0004:	inc     _i
	bne     L0002
	inc     _i+1
	jmp     L0002
;
; }
;
	.dbg	line, "game.c", 247
L0003:	rts

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ draw_bg (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_bg: near

	.dbg	func, "draw_bg", "00", extern, "_draw_bg"

.segment	"CODE"

;
; ppu_off(); // screen off
;
	.dbg	line, "game.c", 84
	jsr     _ppu_off
;
; set_vram_buffer(); // do at least once, sets a pointer to a buffer
;
	.dbg	line, "game.c", 85
	jsr     _set_vram_buffer
;
; p_maps = All_Collision_Maps[which_bg];
;
	.dbg	line, "game.c", 87
	ldx     #$00
	lda     _which_bg
	asl     a
	bcc     L0010
	inx
	clc
L0010:	adc     #<(_All_Collision_Maps)
	sta     ptr1
	txa
	adc     #>(_All_Collision_Maps)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sta     _p_maps+1
	dey
	lda     (ptr1),y
	sta     _p_maps
;
; memcpy (c_map, p_maps, 240);
;
	.dbg	line, "game.c", 89
	lda     #<(_c_map)
	ldx     #>(_c_map)
	jsr     pushax
	lda     _p_maps
	ldx     _p_maps+1
	jsr     pushax
	ldx     #$00
	lda     #$F0
	jsr     _memcpy
;
; set_data_pointer(p_maps);
;
	.dbg	line, "game.c", 90
	lda     _p_maps
	ldx     _p_maps+1
	jsr     _set_data_pointer
;
; set_mt_pointer(mapTiles);
;
	.dbg	line, "game.c", 91
	lda     #<(_mapTiles)
	ldx     #>(_mapTiles)
	jsr     _set_mt_pointer
;
; for(y=0; ;y+=0x20){
;
	.dbg	line, "game.c", 94
	lda     #$00
L000F:	sta     _y
;
; for(x=0; ;x+=0x20){
;
	.dbg	line, "game.c", 95
	lda     #$00
L000E:	sta     _x
;
; address = get_ppu_addr(0, x, y);
;
	.dbg	line, "game.c", 96
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     _x
	dey
	sta     (sp),y
	lda     _y
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; index = (y & 0xf0) + (x >> 4);
;
	.dbg	line, "game.c", 97
	lda     _y
	and     #$F0
	sta     ptr1
	lda     _x
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	clc
	adc     ptr1
	sta     _index
;
; buffer_4_mt(address, index); // ppu_address, index to the data
;
	.dbg	line, "game.c", 98
	lda     _address
	ldx     _address+1
	jsr     pushax
	lda     _index
	jsr     _buffer_4_mt
;
; flush_vram_update2();
;
	.dbg	line, "game.c", 99
	jsr     _flush_vram_update2
;
; if (x == 0xe0) break;
;
	.dbg	line, "game.c", 100
	lda     _x
	cmp     #$E0
	beq     L0011
;
; for(x=0; ;x+=0x20){
;
	.dbg	line, "game.c", 95
	lda     #$20
	clc
	adc     _x
	jmp     L000E
;
; if (y == 0xe0) break;
;
	.dbg	line, "game.c", 102
L0011:	lda     _y
	cmp     #$E0
	beq     L0003
;
; for(y=0; ;y+=0x20){
;
	.dbg	line, "game.c", 94
	lda     #$20
	clc
	adc     _y
	jmp     L000F
;
; ppu_on_all(); // turn on screen
;
	.dbg	line, "game.c", 106
L0003:	jmp     _ppu_on_all

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ abBtn (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_abBtn: near

	.dbg	func, "abBtn", "00", extern, "_abBtn"

.segment	"CODE"

;
; if((pad1_new & PAD_A)||(pad1_new & PAD_B) ){
;
	.dbg	line, "game.c", 110
	lda     _pad1_new
	and     #$80
	bne     L000E
	lda     _pad1_new
	and     #$40
	beq     L000F
;
; if(jump == '0'){
;
	.dbg	line, "game.c", 111
L000E:	lda     _jump
	cmp     #$30
	bne     L000F
;
; jump = '1';
;
	.dbg	line, "game.c", 112
	lda     #$31
	sta     _jump
;
; grnd = '0';
;
	.dbg	line, "game.c", 113
	lda     #$30
	sta     _grnd
;
; dino.y-=2;
;
	.dbg	line, "game.c", 114
	lda     _dino+1
	sec
	sbc     #$02
	sta     _dino+1
;
; dino.sprite = dinoStill;
;
	.dbg	line, "game.c", 115
	lda     #>(_dinoStill)
	sta     _dino+5+1
	lda     #<(_dinoStill)
	sta     _dino+5
;
; if((jump == '1')&&(fall == '0')&&(dino.y > 170)){
;
	.dbg	line, "game.c", 119
L000F:	lda     _jump
	cmp     #$31
	bne     L0012
	lda     _fall
	cmp     #$30
	bne     L0012
	lda     _dino+1
	cmp     #$AB
	bcc     L0012
;
; dino.y-=2;
;
	.dbg	line, "game.c", 120
	sec
	sbc     #$02
	sta     _dino+1
;
; else if((dino.y <= 170)){
;
	.dbg	line, "game.c", 122
	jmp     L0013
L0012:	lda     _dino+1
	cmp     #$AB
	bcs     L0013
;
; dino.y+=2;
;
	.dbg	line, "game.c", 123
	lda     #$02
	clc
	adc     _dino+1
	sta     _dino+1
;
; fall = '1';
;
	.dbg	line, "game.c", 124
	lda     #$31
	sta     _fall
;
; if((fall == '1')){
;
	.dbg	line, "game.c", 126
L0013:	lda     _fall
	cmp     #$31
	bne     L0014
;
; dino.y+=2;
;
	.dbg	line, "game.c", 127
	lda     #$02
	clc
	adc     _dino+1
	sta     _dino+1
;
; if((dino.y >= 211)){
;
	.dbg	line, "game.c", 129
L0014:	lda     _dino+1
	cmp     #$D3
	bcc     L000D
;
; grnd = '1';
;
	.dbg	line, "game.c", 130
	lda     #$31
	sta     _grnd
;
; jump = '0';
;
	.dbg	line, "game.c", 131
	lda     #$30
	sta     _jump
;
; fall = '0';
;
	.dbg	line, "game.c", 132
	sta     _fall
;
; }
;
	.dbg	line, "game.c", 136
L000D:	rts

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ ssBtn (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ssBtn: near

	.dbg	func, "ssBtn", "00", extern, "_ssBtn"

.segment	"CODE"

;
; if((pad1_new & PAD_SELECT)||(pad1_new & PAD_START) ){
;
	.dbg	line, "game.c", 166
	lda     _pad1_new
	ldx     #$00
	and     #$20
	bne     L0009
	lda     _pad1_new
	and     #$10
	bne     L0009
	rts
;
; if (pause == 0){
;
	.dbg	line, "game.c", 167
L0009:	lda     _pause
	ora     _pause+1
	bne     L000A
;
; pause = 1;
;
	.dbg	line, "game.c", 168
	lda     #$01
;
; }else{pause = 0;}
;
	.dbg	line, "game.c", 169
	jmp     L000B
L000A:	txa
L000B:	sta     _pause
	stx     _pause+1
;
; }
;
	.dbg	line, "game.c", 173
	rts

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ moveObs (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_moveObs: near

	.dbg	func, "moveObs", "00", extern, "_moveObs"

.segment	"CODE"

;
; for(i = 0; i < sizeof(obs) / (sizeof(char)*5); i++){
;
	.dbg	line, "game.c", 251
	lda     #$00
	sta     _i
	sta     _i+1
L0002:	lda     _i+1
	cmp     #$00
	bne     L0006
	lda     _i
	cmp     #$05
L0006:	bcc     L0016
;
; }
;
	.dbg	line, "game.c", 279
	rts
;
; if((obs[i].thrown == '0') && (trwTmr == 0)){
;
	.dbg	line, "game.c", 252
L0016:	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	ldy     #$04
	lda     (ptr1),y
	cmp     #$30
	jne     L000D
	lda     _trwTmr
	ora     _trwTmr+1
	jne     L000D
;
; rng = rand8();//sudo randomises the order that the obstacles come at the player
;
	.dbg	line, "game.c", 253
	jsr     _rand8
	sta     _rng
	stx     _rng+1
;
; rng = rng%2;
;
	.dbg	line, "game.c", 254
	jsr     pushax
	ldx     #$00
	lda     #$02
	jsr     tosmoda0
	sta     _rng
	stx     _rng+1
;
; if(rng == 1){
;
	.dbg	line, "game.c", 255
	cpx     #$00
	bne     L000D
	cmp     #$01
	bne     L000D
;
; obs[i].thrown = '1';
;
	.dbg	line, "game.c", 256
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	lda     #$31
	ldy     #$04
	sta     (ptr1),y
;
; trwTmr = 208;
;
	.dbg	line, "game.c", 257
	ldx     #$00
	lda     #$D0
	sta     _trwTmr
	stx     _trwTmr+1
;
; obs[i].x = 234;
;
	.dbg	line, "game.c", 258
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	lda     #$EA
	ldy     #$00
	sta     (ptr1),y
;
; obs[i].sprite = obs[i].ogSpr;
;
	.dbg	line, "game.c", 259
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     sreg
	txa
	adc     #>(_obs)
	sta     sreg+1
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	ldy     #$08
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	ldy     #$05
	sta     (sreg),y
	iny
	txa
	sta     (sreg),y
;
; if(trwTmr > 0){
;
	.dbg	line, "game.c", 263
L000D:	lda     _trwTmr
	cmp     #$01
	lda     _trwTmr+1
	sbc     #$00
	bvs     L0010
	eor     #$80
L0010:	bpl     L0011
;
; trwTmr--;}
;
	.dbg	line, "game.c", 264
	lda     _trwTmr
	sec
	sbc     #$01
	sta     _trwTmr
	bcs     L0011
	dec     _trwTmr+1
;
; if((obs[i].thrown == '1') ){
;
	.dbg	line, "game.c", 266
L0011:	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	ldy     #$04
	lda     (ptr1),y
	cmp     #$31
	bne     L0012
;
; obs[i].x-=2;
;
	.dbg	line, "game.c", 267
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     #$02
	sta     (ptr1),y
;
; if((obs[i].x == 0) ){
;
	.dbg	line, "game.c", 271
L0012:	lda     _i
	ldx     _i+1
	jsr     mulax9
	sta     ptr1
	txa
	clc
	adc     #>(_obs)
	sta     ptr1+1
	ldy     #<(_obs)
	lda     (ptr1),y
	bne     L0004
;
; obs[i].thrown = '0';
;
	.dbg	line, "game.c", 272
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	lda     #$30
	ldy     #$04
	sta     (ptr1),y
;
; obs[i].sprite = null;
;
	.dbg	line, "game.c", 273
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	lda     #<(_null)
	iny
	sta     (ptr1),y
	iny
	lda     #>(_null)
	sta     (ptr1),y
;
; for(i = 0; i < sizeof(obs) / (sizeof(char)*5); i++){
;
	.dbg	line, "game.c", 251
L0004:	inc     _i
	jne     L0002
	inc     _i+1
	jmp     L0002

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ gameOver (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_gameOver: near

	.dbg	func, "gameOver", "00", extern, "_gameOver"

.segment	"CODE"

;
; address = get_ppu_addr(0, 0x50, 0x50); 
;
	.dbg	line, "game.c", 178
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$50
	dey
	sta     (sp),y
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; buffer_1_mt(address, 6);
;
	.dbg	line, "game.c", 179
	jsr     pushax
	lda     #$06
	jsr     _buffer_1_mt
;
; address = get_ppu_addr(0, 0x60, 0x50); 
;
	.dbg	line, "game.c", 180
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$60
	dey
	sta     (sp),y
	lda     #$50
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; buffer_1_mt(address, 7);
;
	.dbg	line, "game.c", 181
	jsr     pushax
	lda     #$07
	jsr     _buffer_1_mt
;
; address = get_ppu_addr(0, 0x80, 0x50); 
;
	.dbg	line, "game.c", 182
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$80
	dey
	sta     (sp),y
	lda     #$50
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; buffer_1_mt(address, 8);
;
	.dbg	line, "game.c", 183
	jsr     pushax
	lda     #$08
	jsr     _buffer_1_mt
;
; address = get_ppu_addr(0, 0x90, 0x50); 
;
	.dbg	line, "game.c", 184
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$90
	dey
	sta     (sp),y
	lda     #$50
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; buffer_1_mt(address, 9);
;
	.dbg	line, "game.c", 185
	jsr     pushax
	lda     #$09
	jsr     _buffer_1_mt
;
; address = get_ppu_addr(0, 0x70, 0x60); 
;
	.dbg	line, "game.c", 186
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$70
	dey
	sta     (sp),y
	lda     #$60
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; buffer_1_mt(address, 10);
;
	.dbg	line, "game.c", 187
	jsr     pushax
	lda     #$0A
	jsr     _buffer_1_mt
;
; ppu_wait_nmi();
;
	.dbg	line, "game.c", 188
	jsr     _ppu_wait_nmi
;
; if(score > hiScr){
;
	.dbg	line, "game.c", 191
	lda     _score
	ldx     _score+1
	jsr     pushax
	lda     _hiScr
	ldx     _hiScr+1
	jsr     tosicmp
	bmi     L0002
	beq     L0002
;
; mapTiles[(5*16)] = mapTiles[(5*13)];
;
	.dbg	line, "game.c", 193
	lda     _mapTiles+65
	sta     _mapTiles+80
;
; mapTiles[(5*16)+1] = mapTiles[(5*13)+1];
;
	.dbg	line, "game.c", 194
	lda     _mapTiles+66
	sta     _mapTiles+81
;
; mapTiles[(5*17)] = mapTiles[(5*14)];
;
	.dbg	line, "game.c", 195
	lda     _mapTiles+70
	sta     _mapTiles+85
;
; mapTiles[(5*17)+1] = mapTiles[(5*14)+1];
;
	.dbg	line, "game.c", 196
	lda     _mapTiles+71
	sta     _mapTiles+86
;
; mapTiles[(5*18)] = mapTiles[(5*15)];
;
	.dbg	line, "game.c", 197
	lda     _mapTiles+75
	sta     _mapTiles+90
;
; pause = 1;
;
	.dbg	line, "game.c", 205
L0002:	ldx     #$00
	lda     #$01
	sta     _pause
	stx     _pause+1
;
; while (pause){ //pause
;
	.dbg	line, "game.c", 206
	jmp     L0006
;
; pad1 = pad_poll(0); 
;
	.dbg	line, "game.c", 207
L0003:	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0); 
;
	.dbg	line, "game.c", 208
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; if((pad1_new & PAD_SELECT)||(pad1_new & PAD_START)||(pad1_new & PAD_A)||(pad1_new & PAD_B) ){
;
	.dbg	line, "game.c", 209
	and     #$20
	bne     L0009
	lda     _pad1_new
	and     #$10
	bne     L0009
	lda     _pad1_new
	and     #$80
	bne     L0009
	lda     _pad1_new
	and     #$40
	beq     L0006
;
; pause = 0;
;
	.dbg	line, "game.c", 211
L0009:	lda     #$00
	sta     _pause
	sta     _pause+1
;
; reset();
;
	.dbg	line, "game.c", 213
	jsr     _reset
;
; while (pause){ //pause
;
	.dbg	line, "game.c", 206
L0006:	lda     _pause
	ora     _pause+1
	bne     L0003
;
; }
;
	.dbg	line, "game.c", 216
	rts

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ displayScore (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_displayScore: near

	.dbg	func, "displayScore", "00", extern, "_displayScore"

.segment	"CODE"

;
; rtnDig(score);
;
	.dbg	line, "game.c", 307
	lda     _score
	ldx     _score+1
	jsr     _rtnDig
;
; address = get_ppu_addr(0, 0xD0, 0x00); 
;
	.dbg	line, "game.c", 311
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$D0
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; mapTiles[(5*13)] = 64 + scrBrd[0];
;
	.dbg	line, "game.c", 312
	lda     _scrBrd
	clc
	adc     #$40
	sta     _mapTiles+65
;
; mapTiles[(5*13)+1] = 64 + scrBrd[1];
;
	.dbg	line, "game.c", 313
	lda     _scrBrd+1
	clc
	adc     #$40
	sta     _mapTiles+66
;
; buffer_1_mt(address, 13);
;
	.dbg	line, "game.c", 314
	lda     _address
	ldx     _address+1
	jsr     pushax
	lda     #$0D
	jsr     _buffer_1_mt
;
; address = get_ppu_addr(0, 0xE0, 0x00); 
;
	.dbg	line, "game.c", 316
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$E0
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; mapTiles[(5*14)] = 64 + scrBrd[2];
;
	.dbg	line, "game.c", 317
	lda     _scrBrd+2
	clc
	adc     #$40
	sta     _mapTiles+70
;
; mapTiles[(5*14)+1] = 64 + scrBrd[3];
;
	.dbg	line, "game.c", 318
	lda     _scrBrd+3
	clc
	adc     #$40
	sta     _mapTiles+71
;
; buffer_1_mt(address, 14);
;
	.dbg	line, "game.c", 319
	lda     _address
	ldx     _address+1
	jsr     pushax
	lda     #$0E
	jsr     _buffer_1_mt
;
; address = get_ppu_addr(0, 0xF0, 0x00); 
;
	.dbg	line, "game.c", 321
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$F0
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; mapTiles[(5*15)] = 64 + scrBrd[4];
;
	.dbg	line, "game.c", 322
	lda     _scrBrd+4
	clc
	adc     #$40
	sta     _mapTiles+75
;
; buffer_1_mt(address, 15);
;
	.dbg	line, "game.c", 323
	lda     _address
	ldx     _address+1
	jsr     pushax
	lda     #$0F
	jsr     _buffer_1_mt
;
; counter = 4;
;
	.dbg	line, "game.c", 324
	ldx     #$00
	lda     #$04
	sta     _counter
	stx     _counter+1
;
; address = get_ppu_addr(0, 0x80, 0x00); 
;
	.dbg	line, "game.c", 327
	jsr     decsp2
	txa
	ldy     #$01
	sta     (sp),y
	lda     #$80
	dey
	sta     (sp),y
	txa
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; buffer_1_mt(address, 11);
;
	.dbg	line, "game.c", 328
	jsr     pushax
	lda     #$0B
	jsr     _buffer_1_mt
;
; address = get_ppu_addr(0, 0x90, 0x00); 
;
	.dbg	line, "game.c", 329
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$90
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; buffer_1_mt(address, 12);
;
	.dbg	line, "game.c", 330
	jsr     pushax
	lda     #$0C
	jsr     _buffer_1_mt
;
; address = get_ppu_addr(0, 0xA0, 0x00); 
;
	.dbg	line, "game.c", 332
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$A0
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; buffer_1_mt(address, 16);
;
	.dbg	line, "game.c", 333
	jsr     pushax
	lda     #$10
	jsr     _buffer_1_mt
;
; address = get_ppu_addr(0, 0xB0, 0x00); 
;
	.dbg	line, "game.c", 334
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$B0
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; buffer_1_mt(address, 17);
;
	.dbg	line, "game.c", 335
	jsr     pushax
	lda     #$11
	jsr     _buffer_1_mt
;
; address = get_ppu_addr(0, 0xC0, 0x00); 
;
	.dbg	line, "game.c", 336
	jsr     decsp2
	lda     #$00
	ldy     #$01
	sta     (sp),y
	lda     #$C0
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	sta     _address
	stx     _address+1
;
; buffer_1_mt(address, 18);
;
	.dbg	line, "game.c", 337
	jsr     pushax
	lda     #$12
	jmp     _buffer_1_mt

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ reset (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_reset: near

	.dbg	func, "reset", "00", extern, "_reset"

.segment	"CODE"

;
; score = 0;
;
	.dbg	line, "game.c", 282
	lda     #$00
	sta     _score
	sta     _score+1
;
; for(i = 0; i < sizeof(obs) / (sizeof(char)*5); i++){
;
	.dbg	line, "game.c", 283
	sta     _i
	sta     _i+1
L0002:	lda     _i+1
	cmp     #$00
	bne     L0006
	lda     _i
	cmp     #$05
L0006:	bcs     L0003
;
; obs[i].thrown = '0';
;
	.dbg	line, "game.c", 284
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	lda     #$30
	ldy     #$04
	sta     (ptr1),y
;
; obs[i].sprite = null;
;
	.dbg	line, "game.c", 285
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	lda     #<(_null)
	iny
	sta     (ptr1),y
	iny
	lda     #>(_null)
	sta     (ptr1),y
;
; obs[i].x = 254;
;
	.dbg	line, "game.c", 286
	lda     _i
	ldx     _i+1
	jsr     mulax9
	clc
	adc     #<(_obs)
	sta     ptr1
	txa
	adc     #>(_obs)
	sta     ptr1+1
	lda     #$FE
	ldy     #$00
	sta     (ptr1),y
;
; for(i = 0; i < sizeof(obs) / (sizeof(char)*5); i++){
;
	.dbg	line, "game.c", 283
	inc     _i
	bne     L0002
	inc     _i+1
	jmp     L0002
;
; dino.sprite=dinoSp1;
;
	.dbg	line, "game.c", 288
L0003:	lda     #>(_dinoSp1)
	sta     _dino+5+1
	lda     #<(_dinoSp1)
	sta     _dino+5
;
; dino.y = 211;
;
	.dbg	line, "game.c", 289
	lda     #$D3
	sta     _dino+1
;
; mapTiles[(5*13)] = 64;
;
	.dbg	line, "game.c", 291
	lda     #$40
	sta     _mapTiles+65
;
; mapTiles[(5*13)+1] = 64;
;
	.dbg	line, "game.c", 292
	sta     _mapTiles+66
;
; mapTiles[(5*14)] = 64;
;
	.dbg	line, "game.c", 293
	sta     _mapTiles+70
;
; mapTiles[(5*14)+1] = 64;
;
	.dbg	line, "game.c", 294
	sta     _mapTiles+71
;
; mapTiles[(5*15)] = 64;
;
	.dbg	line, "game.c", 295
	sta     _mapTiles+75
;
; for(i = 0; i < 10; i++){
;
	.dbg	line, "game.c", 299
	lda     #$00
	sta     _i
	sta     _i+1
L0008:	lda     _i
	cmp     #$0A
	lda     _i+1
	sbc     #$00
	bvc     L000C
	eor     #$80
L000C:	bpl     L0009
;
; scrBrd[i] = 0;
;
	.dbg	line, "game.c", 300
	lda     _i
	clc
	adc     #<(_scrBrd)
	sta     ptr1
	lda     _i+1
	adc     #>(_scrBrd)
	sta     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
;
; for(i = 0; i < 10; i++){
;
	.dbg	line, "game.c", 299
	inc     _i
	bne     L0008
	inc     _i+1
	jmp     L0008
;
; draw_bg();
;
	.dbg	line, "game.c", 302
L0009:	jmp     _draw_bg

	.dbg	line
.endproc

; ---------------------------------------------------------------
; int __near__ rtnDig (int value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_rtnDig: near

	.dbg	func, "rtnDig", "00", extern, "_rtnDig"
	.dbg	sym, "value", "00", auto, 0

.segment	"CODE"

;
; int rtnDig(value){
;
	.dbg	line, "game.c", 343
	jsr     pushax
;
; digit = value % 10;
;
	.dbg	line, "game.c", 346
	jsr     pushw0sp
	ldy     #$00
	ldx     #$00
	lda     #$0A
	jsr     tosmoda0
	sta     _digit
	stx     _digit+1
;
; scrBrd[counter] = digit;
;
	.dbg	line, "game.c", 347
	lda     _counter
	clc
	adc     #<(_scrBrd)
	sta     ptr1
	lda     _counter+1
	adc     #>(_scrBrd)
	sta     ptr1+1
	lda     _digit
	ldy     #$00
	sta     (ptr1),y
;
; counter--;
;
	.dbg	line, "game.c", 349
	lda     _counter
	sec
	sbc     #$01
	sta     _counter
	bcs     L0002
	dec     _counter+1
;
; if(value >= 10){
;
	.dbg	line, "game.c", 350
L0002:	iny
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	cmp     #$0A
	txa
	sbc     #$00
	bvs     L0004
	eor     #$80
L0004:	bpl     L0003
;
; rtnDig(value / 10);
;
	.dbg	line, "game.c", 352
	jsr     pushw0sp
	lda     #$0A
	jsr     tosdiva0
	jsr     _rtnDig
;
; return digit;
;
	.dbg	line, "game.c", 355
L0003:	lda     _digit
	ldx     _digit+1
;
; }
;
	.dbg	line, "game.c", 356
	jmp     incsp2

	.dbg	line
.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

	.dbg	func, "main", "00", extern, "_main"

.segment	"CODE"

;
; ppu_off(); // screen off
;
	.dbg	line, "game.c", 13
	jsr     _ppu_off
;
; obs[0] = cacti;
;
	.dbg	line, "game.c", 14
	lda     #<(_obs)
	ldx     #>(_obs)
	jsr     pushax
	lda     #<(_cacti)
	ldx     #>(_cacti)
	jsr     pushax
	ldx     #$00
	lda     #$09
	jsr     _memcpy
;
; obs[1] = cacti2;
;
	.dbg	line, "game.c", 15
	lda     #<(_obs+9)
	ldx     #>(_obs+9)
	jsr     pushax
	lda     #<(_cacti2)
	ldx     #>(_cacti2)
	jsr     pushax
	ldx     #$00
	lda     #$09
	jsr     _memcpy
;
; obs[2] = birb;
;
	.dbg	line, "game.c", 16
	lda     #<(_obs+18)
	ldx     #>(_obs+18)
	jsr     pushax
	lda     #<(_birb)
	ldx     #>(_birb)
	jsr     pushax
	ldx     #$00
	lda     #$09
	jsr     _memcpy
;
; pal_bg(paletteBg); // load the BG palette
;
	.dbg	line, "game.c", 17
	lda     #<(_paletteBg)
	ldx     #>(_paletteBg)
	jsr     _pal_bg
;
; pal_spr(paletteSp);//load the sprite palette
;
	.dbg	line, "game.c", 18
	lda     #<(_paletteSp)
	ldx     #>(_paletteSp)
	jsr     _pal_spr
;
; bank_spr(1);
;
	.dbg	line, "game.c", 19
	lda     #$01
	jsr     _bank_spr
;
; vram_adr(NTADR_A(3,3)); // screen is 32 x 30 tiles
;
	.dbg	line, "game.c", 22
	ldx     #$20
	lda     #$63
	jsr     _vram_adr
;
; set_vram_buffer(); // do at least once, sets a pointer to a buffer
;
	.dbg	line, "game.c", 25
	jsr     _set_vram_buffer
;
; draw_bg();
;
	.dbg	line, "game.c", 26
	jsr     _draw_bg
;
; ppu_on_all(); // turn on screen now in draw_bg();
;
	.dbg	line, "game.c", 31
	jsr     _ppu_on_all
;
; while (loop){
;
	.dbg	line, "game.c", 36
	jmp     L0007
;
; ppu_wait_nmi();
;
	.dbg	line, "game.c", 39
L0002:	jsr     _ppu_wait_nmi
;
; pad1 = pad_poll(0); //read first controller input
;
	.dbg	line, "game.c", 40
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0); // newly pressed button. do pad_poll first
;
	.dbg	line, "game.c", 41
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; moveCloud();
;
	.dbg	line, "game.c", 42
	jsr     _moveCloud
;
; moveObs();
;
	.dbg	line, "game.c", 43
	jsr     _moveObs
;
; checkCollision();
;
	.dbg	line, "game.c", 44
	jsr     _checkCollision
;
; drawSprites();
;
	.dbg	line, "game.c", 45
	jsr     _drawSprites
;
; abBtn();
;
	.dbg	line, "game.c", 46
	jsr     _abBtn
;
; walk();
;
	.dbg	line, "game.c", 47
	jsr     _walk
;
; displayScore();
;
	.dbg	line, "game.c", 48
	jsr     _displayScore
;
; score++;
;
	.dbg	line, "game.c", 49
	inc     _score
	bne     L0008
	inc     _score+1
;
; while (pause){ //pause
;
	.dbg	line, "game.c", 52
	jmp     L0008
;
; pad1 = pad_poll(0); 
;
	.dbg	line, "game.c", 53
L0006:	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0); 
;
	.dbg	line, "game.c", 54
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; ssBtn();
;
	.dbg	line, "game.c", 55
	jsr     _ssBtn
;
; while (pause){ //pause
;
	.dbg	line, "game.c", 52
L0008:	lda     _pause
	ora     _pause+1
	bne     L0006
;
; while (loop){
;
	.dbg	line, "game.c", 36
L0007:	lda     _loop
	ora     _loop+1
	bne     L0002
;
; while (1){ //prevents crashes on "win"
;
	.dbg	line, "game.c", 58
L000C:	jmp     L000C

	.dbg	line
.endproc

